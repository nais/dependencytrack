/*
OWASP Dependency-Track

REST API of OWASP Dependency-Track

API version: 4.13.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type NotificationAPI interface {

	/*
	AddProjectToRule Adds a project to a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleUuid The UUID of the rule to add a project to
	@param projectUuid The UUID of the project to add to the rule
	@return ApiAddProjectToRuleRequest
	*/
	AddProjectToRule(ctx context.Context, ruleUuid string, projectUuid string) ApiAddProjectToRuleRequest

	// AddProjectToRuleExecute executes the request
	//  @return NotificationRule
	AddProjectToRuleExecute(r ApiAddProjectToRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	AddTeamToRule Adds a team to a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleUuid The UUID of the rule to add a team to
	@param teamUuid The UUID of the team to add to the rule
	@return ApiAddTeamToRuleRequest
	*/
	AddTeamToRule(ctx context.Context, ruleUuid string, teamUuid string) ApiAddTeamToRuleRequest

	// AddTeamToRuleExecute executes the request
	//  @return NotificationRule
	AddTeamToRuleExecute(r ApiAddTeamToRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	CreateNotificationPublisher Creates a new notification publisher

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateNotificationPublisherRequest
	*/
	CreateNotificationPublisher(ctx context.Context) ApiCreateNotificationPublisherRequest

	// CreateNotificationPublisherExecute executes the request
	//  @return NotificationPublisher
	CreateNotificationPublisherExecute(r ApiCreateNotificationPublisherRequest) (*NotificationPublisher, *http.Response, error)

	/*
	CreateNotificationRule Creates a new notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateNotificationRuleRequest
	*/
	CreateNotificationRule(ctx context.Context) ApiCreateNotificationRuleRequest

	// CreateNotificationRuleExecute executes the request
	//  @return NotificationRule
	CreateNotificationRuleExecute(r ApiCreateNotificationRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	CreateScheduledNotificationRule Creates a new scheduled notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateScheduledNotificationRuleRequest
	*/
	CreateScheduledNotificationRule(ctx context.Context) ApiCreateScheduledNotificationRuleRequest

	// CreateScheduledNotificationRuleExecute executes the request
	//  @return NotificationRule
	CreateScheduledNotificationRuleExecute(r ApiCreateScheduledNotificationRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	DeleteNotificationPublisher Deletes a notification publisher and all related notification rules

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param notificationPublisherUuid The UUID of the notification publisher to delete
	@return ApiDeleteNotificationPublisherRequest
	*/
	DeleteNotificationPublisher(ctx context.Context, notificationPublisherUuid string) ApiDeleteNotificationPublisherRequest

	// DeleteNotificationPublisherExecute executes the request
	DeleteNotificationPublisherExecute(r ApiDeleteNotificationPublisherRequest) (*http.Response, error)

	/*
	DeleteNotificationRule Deletes a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteNotificationRuleRequest
	*/
	DeleteNotificationRule(ctx context.Context) ApiDeleteNotificationRuleRequest

	// DeleteNotificationRuleExecute executes the request
	DeleteNotificationRuleExecute(r ApiDeleteNotificationRuleRequest) (*http.Response, error)

	/*
	GetAllNotificationPublishers Returns a list of all notification publishers

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllNotificationPublishersRequest
	*/
	GetAllNotificationPublishers(ctx context.Context) ApiGetAllNotificationPublishersRequest

	// GetAllNotificationPublishersExecute executes the request
	//  @return []NotificationPublisher
	GetAllNotificationPublishersExecute(r ApiGetAllNotificationPublishersRequest) ([]NotificationPublisher, *http.Response, error)

	/*
	GetAllNotificationRules Returns a list of all notification rules

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllNotificationRulesRequest
	*/
	GetAllNotificationRules(ctx context.Context) ApiGetAllNotificationRulesRequest

	// GetAllNotificationRulesExecute executes the request
	//  @return []NotificationRule
	GetAllNotificationRulesExecute(r ApiGetAllNotificationRulesRequest) ([]NotificationRule, *http.Response, error)

	/*
	RemoveProjectFromRule Removes a project from a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleUuid The UUID of the rule to remove the project from
	@param projectUuid The UUID of the project to remove from the rule
	@return ApiRemoveProjectFromRuleRequest
	*/
	RemoveProjectFromRule(ctx context.Context, ruleUuid string, projectUuid string) ApiRemoveProjectFromRuleRequest

	// RemoveProjectFromRuleExecute executes the request
	//  @return NotificationRule
	RemoveProjectFromRuleExecute(r ApiRemoveProjectFromRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	RemoveTeamFromRule Removes a team from a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleUuid The UUID of the rule to remove the project from
	@param teamUuid The UUID of the project to remove from the rule
	@return ApiRemoveTeamFromRuleRequest
	*/
	RemoveTeamFromRule(ctx context.Context, ruleUuid string, teamUuid string) ApiRemoveTeamFromRuleRequest

	// RemoveTeamFromRuleExecute executes the request
	//  @return NotificationRule
	RemoveTeamFromRuleExecute(r ApiRemoveTeamFromRuleRequest) (*NotificationRule, *http.Response, error)

	/*
	RestoreDefaultTemplates Restore the default notification publisher templates using the ones in the solution classpath

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRestoreDefaultTemplatesRequest
	*/
	RestoreDefaultTemplates(ctx context.Context) ApiRestoreDefaultTemplatesRequest

	// RestoreDefaultTemplatesExecute executes the request
	RestoreDefaultTemplatesExecute(r ApiRestoreDefaultTemplatesRequest) (*http.Response, error)

	/*
	TestNotificationRule Dispatches a rule notification test

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the rule to test
	@return ApiTestNotificationRuleRequest
	*/
	TestNotificationRule(ctx context.Context, uuid string) ApiTestNotificationRuleRequest

	// TestNotificationRuleExecute executes the request
	TestNotificationRuleExecute(r ApiTestNotificationRuleRequest) (*http.Response, error)

	/*
	TestSmtpPublisherConfig Dispatches a SMTP notification test

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestSmtpPublisherConfigRequest
	*/
	TestSmtpPublisherConfig(ctx context.Context) ApiTestSmtpPublisherConfigRequest

	// TestSmtpPublisherConfigExecute executes the request
	TestSmtpPublisherConfigExecute(r ApiTestSmtpPublisherConfigRequest) (*http.Response, error)

	/*
	UpdateNotificationPublisher Updates a notification publisher

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateNotificationPublisherRequest
	*/
	UpdateNotificationPublisher(ctx context.Context) ApiUpdateNotificationPublisherRequest

	// UpdateNotificationPublisherExecute executes the request
	//  @return NotificationPublisher
	UpdateNotificationPublisherExecute(r ApiUpdateNotificationPublisherRequest) (*NotificationPublisher, *http.Response, error)

	/*
	UpdateNotificationRule Updates a notification rule

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateNotificationRuleRequest
	*/
	UpdateNotificationRule(ctx context.Context) ApiUpdateNotificationRuleRequest

	// UpdateNotificationRuleExecute executes the request
	//  @return NotificationRule
	UpdateNotificationRuleExecute(r ApiUpdateNotificationRuleRequest) (*NotificationRule, *http.Response, error)
}

// NotificationAPIService NotificationAPI service
type NotificationAPIService service

type ApiAddProjectToRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	ruleUuid string
	projectUuid string
}

func (r ApiAddProjectToRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.AddProjectToRuleExecute(r)
}

/*
AddProjectToRule Adds a project to a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleUuid The UUID of the rule to add a project to
 @param projectUuid The UUID of the project to add to the rule
 @return ApiAddProjectToRuleRequest
*/
func (a *NotificationAPIService) AddProjectToRule(ctx context.Context, ruleUuid string, projectUuid string) ApiAddProjectToRuleRequest {
	return ApiAddProjectToRuleRequest{
		ApiService: a,
		ctx: ctx,
		ruleUuid: ruleUuid,
		projectUuid: projectUuid,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) AddProjectToRuleExecute(r ApiAddProjectToRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.AddProjectToRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule/{ruleUuid}/project/{projectUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleUuid"+"}", url.PathEscape(parameterValueToString(r.ruleUuid, "ruleUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUuid"+"}", url.PathEscape(parameterValueToString(r.projectUuid, "projectUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTeamToRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	ruleUuid string
	teamUuid string
}

func (r ApiAddTeamToRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.AddTeamToRuleExecute(r)
}

/*
AddTeamToRule Adds a team to a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleUuid The UUID of the rule to add a team to
 @param teamUuid The UUID of the team to add to the rule
 @return ApiAddTeamToRuleRequest
*/
func (a *NotificationAPIService) AddTeamToRule(ctx context.Context, ruleUuid string, teamUuid string) ApiAddTeamToRuleRequest {
	return ApiAddTeamToRuleRequest{
		ApiService: a,
		ctx: ctx,
		ruleUuid: ruleUuid,
		teamUuid: teamUuid,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) AddTeamToRuleExecute(r ApiAddTeamToRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.AddTeamToRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule/{ruleUuid}/team/{teamUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleUuid"+"}", url.PathEscape(parameterValueToString(r.ruleUuid, "ruleUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamUuid"+"}", url.PathEscape(parameterValueToString(r.teamUuid, "teamUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNotificationPublisherRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationPublisher *NotificationPublisher
}

func (r ApiCreateNotificationPublisherRequest) NotificationPublisher(notificationPublisher NotificationPublisher) ApiCreateNotificationPublisherRequest {
	r.notificationPublisher = &notificationPublisher
	return r
}

func (r ApiCreateNotificationPublisherRequest) Execute() (*NotificationPublisher, *http.Response, error) {
	return r.ApiService.CreateNotificationPublisherExecute(r)
}

/*
CreateNotificationPublisher Creates a new notification publisher

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNotificationPublisherRequest
*/
func (a *NotificationAPIService) CreateNotificationPublisher(ctx context.Context) ApiCreateNotificationPublisherRequest {
	return ApiCreateNotificationPublisherRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationPublisher
func (a *NotificationAPIService) CreateNotificationPublisherExecute(r ApiCreateNotificationPublisherRequest) (*NotificationPublisher, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationPublisher
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.CreateNotificationPublisher")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationPublisher
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNotificationRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationRule *NotificationRule
}

func (r ApiCreateNotificationRuleRequest) NotificationRule(notificationRule NotificationRule) ApiCreateNotificationRuleRequest {
	r.notificationRule = &notificationRule
	return r
}

func (r ApiCreateNotificationRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.CreateNotificationRuleExecute(r)
}

/*
CreateNotificationRule Creates a new notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNotificationRuleRequest
*/
func (a *NotificationAPIService) CreateNotificationRule(ctx context.Context) ApiCreateNotificationRuleRequest {
	return ApiCreateNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) CreateNotificationRuleExecute(r ApiCreateNotificationRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.CreateNotificationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateScheduledNotificationRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	createScheduledNotificationRuleRequest *CreateScheduledNotificationRuleRequest
}

func (r ApiCreateScheduledNotificationRuleRequest) CreateScheduledNotificationRuleRequest(createScheduledNotificationRuleRequest CreateScheduledNotificationRuleRequest) ApiCreateScheduledNotificationRuleRequest {
	r.createScheduledNotificationRuleRequest = &createScheduledNotificationRuleRequest
	return r
}

func (r ApiCreateScheduledNotificationRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.CreateScheduledNotificationRuleExecute(r)
}

/*
CreateScheduledNotificationRule Creates a new scheduled notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateScheduledNotificationRuleRequest
*/
func (a *NotificationAPIService) CreateScheduledNotificationRule(ctx context.Context) ApiCreateScheduledNotificationRuleRequest {
	return ApiCreateScheduledNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) CreateScheduledNotificationRuleExecute(r ApiCreateScheduledNotificationRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.CreateScheduledNotificationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule/scheduled"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createScheduledNotificationRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteNotificationPublisherRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationPublisherUuid string
}

func (r ApiDeleteNotificationPublisherRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNotificationPublisherExecute(r)
}

/*
DeleteNotificationPublisher Deletes a notification publisher and all related notification rules

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param notificationPublisherUuid The UUID of the notification publisher to delete
 @return ApiDeleteNotificationPublisherRequest
*/
func (a *NotificationAPIService) DeleteNotificationPublisher(ctx context.Context, notificationPublisherUuid string) ApiDeleteNotificationPublisherRequest {
	return ApiDeleteNotificationPublisherRequest{
		ApiService: a,
		ctx: ctx,
		notificationPublisherUuid: notificationPublisherUuid,
	}
}

// Execute executes the request
func (a *NotificationAPIService) DeleteNotificationPublisherExecute(r ApiDeleteNotificationPublisherRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.DeleteNotificationPublisher")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher/{notificationPublisherUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"notificationPublisherUuid"+"}", url.PathEscape(parameterValueToString(r.notificationPublisherUuid, "notificationPublisherUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNotificationRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationRule *NotificationRule
}

func (r ApiDeleteNotificationRuleRequest) NotificationRule(notificationRule NotificationRule) ApiDeleteNotificationRuleRequest {
	r.notificationRule = &notificationRule
	return r
}

func (r ApiDeleteNotificationRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNotificationRuleExecute(r)
}

/*
DeleteNotificationRule Deletes a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteNotificationRuleRequest
*/
func (a *NotificationAPIService) DeleteNotificationRule(ctx context.Context) ApiDeleteNotificationRuleRequest {
	return ApiDeleteNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NotificationAPIService) DeleteNotificationRuleExecute(r ApiDeleteNotificationRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.DeleteNotificationRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllNotificationPublishersRequest struct {
	ctx context.Context
	ApiService NotificationAPI
}

func (r ApiGetAllNotificationPublishersRequest) Execute() ([]NotificationPublisher, *http.Response, error) {
	return r.ApiService.GetAllNotificationPublishersExecute(r)
}

/*
GetAllNotificationPublishers Returns a list of all notification publishers

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllNotificationPublishersRequest
*/
func (a *NotificationAPIService) GetAllNotificationPublishers(ctx context.Context) ApiGetAllNotificationPublishersRequest {
	return ApiGetAllNotificationPublishersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationPublisher
func (a *NotificationAPIService) GetAllNotificationPublishersExecute(r ApiGetAllNotificationPublishersRequest) ([]NotificationPublisher, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationPublisher
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.GetAllNotificationPublishers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllNotificationRulesRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
	triggerType *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetAllNotificationRulesRequest) PageNumber(pageNumber string) ApiGetAllNotificationRulesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetAllNotificationRulesRequest) PageSize(pageSize string) ApiGetAllNotificationRulesRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetAllNotificationRulesRequest) Offset(offset string) ApiGetAllNotificationRulesRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetAllNotificationRulesRequest) Limit(limit string) ApiGetAllNotificationRulesRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetAllNotificationRulesRequest) SortName(sortName string) ApiGetAllNotificationRulesRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetAllNotificationRulesRequest) SortOrder(sortOrder string) ApiGetAllNotificationRulesRequest {
	r.sortOrder = &sortOrder
	return r
}

// The notification trigger type to filter on
func (r ApiGetAllNotificationRulesRequest) TriggerType(triggerType string) ApiGetAllNotificationRulesRequest {
	r.triggerType = &triggerType
	return r
}

func (r ApiGetAllNotificationRulesRequest) Execute() ([]NotificationRule, *http.Response, error) {
	return r.ApiService.GetAllNotificationRulesExecute(r)
}

/*
GetAllNotificationRules Returns a list of all notification rules

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllNotificationRulesRequest
*/
func (a *NotificationAPIService) GetAllNotificationRules(ctx context.Context) ApiGetAllNotificationRulesRequest {
	return ApiGetAllNotificationRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NotificationRule
func (a *NotificationAPIService) GetAllNotificationRulesExecute(r ApiGetAllNotificationRulesRequest) ([]NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.GetAllNotificationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
        var defaultValue string = "1"
        parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", defaultValue, "form", "")
        r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
        var defaultValue string = "100"
        parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", defaultValue, "form", "")
        r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.triggerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "triggerType", r.triggerType, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveProjectFromRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	ruleUuid string
	projectUuid string
}

func (r ApiRemoveProjectFromRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.RemoveProjectFromRuleExecute(r)
}

/*
RemoveProjectFromRule Removes a project from a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleUuid The UUID of the rule to remove the project from
 @param projectUuid The UUID of the project to remove from the rule
 @return ApiRemoveProjectFromRuleRequest
*/
func (a *NotificationAPIService) RemoveProjectFromRule(ctx context.Context, ruleUuid string, projectUuid string) ApiRemoveProjectFromRuleRequest {
	return ApiRemoveProjectFromRuleRequest{
		ApiService: a,
		ctx: ctx,
		ruleUuid: ruleUuid,
		projectUuid: projectUuid,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) RemoveProjectFromRuleExecute(r ApiRemoveProjectFromRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.RemoveProjectFromRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule/{ruleUuid}/project/{projectUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleUuid"+"}", url.PathEscape(parameterValueToString(r.ruleUuid, "ruleUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"projectUuid"+"}", url.PathEscape(parameterValueToString(r.projectUuid, "projectUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveTeamFromRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	ruleUuid string
	teamUuid string
}

func (r ApiRemoveTeamFromRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.RemoveTeamFromRuleExecute(r)
}

/*
RemoveTeamFromRule Removes a team from a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param ruleUuid The UUID of the rule to remove the project from
 @param teamUuid The UUID of the project to remove from the rule
 @return ApiRemoveTeamFromRuleRequest
*/
func (a *NotificationAPIService) RemoveTeamFromRule(ctx context.Context, ruleUuid string, teamUuid string) ApiRemoveTeamFromRuleRequest {
	return ApiRemoveTeamFromRuleRequest{
		ApiService: a,
		ctx: ctx,
		ruleUuid: ruleUuid,
		teamUuid: teamUuid,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) RemoveTeamFromRuleExecute(r ApiRemoveTeamFromRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.RemoveTeamFromRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule/{ruleUuid}/team/{teamUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleUuid"+"}", url.PathEscape(parameterValueToString(r.ruleUuid, "ruleUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"teamUuid"+"}", url.PathEscape(parameterValueToString(r.teamUuid, "teamUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreDefaultTemplatesRequest struct {
	ctx context.Context
	ApiService NotificationAPI
}

func (r ApiRestoreDefaultTemplatesRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestoreDefaultTemplatesExecute(r)
}

/*
RestoreDefaultTemplates Restore the default notification publisher templates using the ones in the solution classpath

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRestoreDefaultTemplatesRequest
*/
func (a *NotificationAPIService) RestoreDefaultTemplates(ctx context.Context) ApiRestoreDefaultTemplatesRequest {
	return ApiRestoreDefaultTemplatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NotificationAPIService) RestoreDefaultTemplatesExecute(r ApiRestoreDefaultTemplatesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.RestoreDefaultTemplates")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher/restoreDefaultTemplates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestNotificationRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	uuid string
}

func (r ApiTestNotificationRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestNotificationRuleExecute(r)
}

/*
TestNotificationRule Dispatches a rule notification test

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the rule to test
 @return ApiTestNotificationRuleRequest
*/
func (a *NotificationAPIService) TestNotificationRule(ctx context.Context, uuid string) ApiTestNotificationRuleRequest {
	return ApiTestNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *NotificationAPIService) TestNotificationRuleExecute(r ApiTestNotificationRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.TestNotificationRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher/test/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestSmtpPublisherConfigRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	destination *string
}

func (r ApiTestSmtpPublisherConfigRequest) Destination(destination string) ApiTestSmtpPublisherConfigRequest {
	r.destination = &destination
	return r
}

func (r ApiTestSmtpPublisherConfigRequest) Execute() (*http.Response, error) {
	return r.ApiService.TestSmtpPublisherConfigExecute(r)
}

/*
TestSmtpPublisherConfig Dispatches a SMTP notification test

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestSmtpPublisherConfigRequest
*/
func (a *NotificationAPIService) TestSmtpPublisherConfig(ctx context.Context) ApiTestSmtpPublisherConfigRequest {
	return ApiTestSmtpPublisherConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *NotificationAPIService) TestSmtpPublisherConfigExecute(r ApiTestSmtpPublisherConfigRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.TestSmtpPublisherConfig")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher/test/smtp"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.destination != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "destination", r.destination, "", "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateNotificationPublisherRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationPublisher *NotificationPublisher
}

func (r ApiUpdateNotificationPublisherRequest) NotificationPublisher(notificationPublisher NotificationPublisher) ApiUpdateNotificationPublisherRequest {
	r.notificationPublisher = &notificationPublisher
	return r
}

func (r ApiUpdateNotificationPublisherRequest) Execute() (*NotificationPublisher, *http.Response, error) {
	return r.ApiService.UpdateNotificationPublisherExecute(r)
}

/*
UpdateNotificationPublisher Updates a notification publisher

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNotificationPublisherRequest
*/
func (a *NotificationAPIService) UpdateNotificationPublisher(ctx context.Context) ApiUpdateNotificationPublisherRequest {
	return ApiUpdateNotificationPublisherRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationPublisher
func (a *NotificationAPIService) UpdateNotificationPublisherExecute(r ApiUpdateNotificationPublisherRequest) (*NotificationPublisher, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationPublisher
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.UpdateNotificationPublisher")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/publisher"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationPublisher
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNotificationRuleRequest struct {
	ctx context.Context
	ApiService NotificationAPI
	notificationRule *NotificationRule
}

func (r ApiUpdateNotificationRuleRequest) NotificationRule(notificationRule NotificationRule) ApiUpdateNotificationRuleRequest {
	r.notificationRule = &notificationRule
	return r
}

func (r ApiUpdateNotificationRuleRequest) Execute() (*NotificationRule, *http.Response, error) {
	return r.ApiService.UpdateNotificationRuleExecute(r)
}

/*
UpdateNotificationRule Updates a notification rule

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateNotificationRuleRequest
*/
func (a *NotificationAPIService) UpdateNotificationRule(ctx context.Context) ApiUpdateNotificationRuleRequest {
	return ApiUpdateNotificationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NotificationRule
func (a *NotificationAPIService) UpdateNotificationRuleExecute(r ApiUpdateNotificationRuleRequest) (*NotificationRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NotificationRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "NotificationAPIService.UpdateNotificationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/notification/rule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notificationRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
