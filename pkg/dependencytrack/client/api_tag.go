/*
OWASP Dependency-Track

REST API of OWASP Dependency-Track

API version: 4.13.5
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type TagAPI interface {

	/*
	CreateTags Creates one or more tags.

	<p>Requires permission <strong>TAG_MANAGEMENT</strong></p>


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTagsRequest
	*/
	CreateTags(ctx context.Context) ApiCreateTagsRequest

	// CreateTagsExecute executes the request
	CreateTagsExecute(r ApiCreateTagsRequest) (*http.Response, error)

	/*
	DeleteTags Deletes one or more tags.

	<p>A tag can only be deleted if no projects or policies are assigned to it.</p>
<p>
  Principals with <strong>PORTFOLIO_MANAGEMENT</strong> permission, and access
  to <em>all</em> assigned projects (if portfolio ACL is enabled), can delete
  a tag with assigned projects.
</p>
<p>
  Principals with <strong>POLICY_MANAGEMENT</strong> permission can delete tags
  with assigned policies.
</p>
<p>Requires permission <strong>TAG_MANAGEMENT</strong></p>


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteTagsRequest
	*/
	DeleteTags(ctx context.Context) ApiDeleteTagsRequest

	// DeleteTagsExecute executes the request
	DeleteTagsExecute(r ApiDeleteTagsRequest) (*http.Response, error)

	/*
	GetAllTags Returns a list of all tags

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllTagsRequest
	*/
	GetAllTags(ctx context.Context) ApiGetAllTagsRequest

	// GetAllTagsExecute executes the request
	//  @return []TagListResponseItem
	GetAllTagsExecute(r ApiGetAllTagsRequest) ([]TagListResponseItem, *http.Response, error)

	/*
	GetTaggedCollectionProjects Returns a list of all collection projects that use the given tag for their collection logic.

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to get collection projects for
	@return ApiGetTaggedCollectionProjectsRequest
	*/
	GetTaggedCollectionProjects(ctx context.Context, name string) ApiGetTaggedCollectionProjectsRequest

	// GetTaggedCollectionProjectsExecute executes the request
	//  @return []TaggedCollectionProjectListResponseItem
	GetTaggedCollectionProjectsExecute(r ApiGetTaggedCollectionProjectsRequest) ([]TaggedCollectionProjectListResponseItem, *http.Response, error)

	/*
	GetTaggedNotificationRules Returns a list of all notification rules assigned to the given tag.

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to get notification rules for
	@return ApiGetTaggedNotificationRulesRequest
	*/
	GetTaggedNotificationRules(ctx context.Context, name string) ApiGetTaggedNotificationRulesRequest

	// GetTaggedNotificationRulesExecute executes the request
	//  @return []TaggedPolicyListResponseItem
	GetTaggedNotificationRulesExecute(r ApiGetTaggedNotificationRulesRequest) ([]TaggedPolicyListResponseItem, *http.Response, error)

	/*
	GetTaggedPolicies Returns a list of all policies assigned to the given tag.

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to get policies for
	@return ApiGetTaggedPoliciesRequest
	*/
	GetTaggedPolicies(ctx context.Context, name string) ApiGetTaggedPoliciesRequest

	// GetTaggedPoliciesExecute executes the request
	//  @return []TaggedPolicyListResponseItem
	GetTaggedPoliciesExecute(r ApiGetTaggedPoliciesRequest) ([]TaggedPolicyListResponseItem, *http.Response, error)

	/*
	GetTaggedProjects Returns a list of all projects assigned to the given tag.

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to get projects for
	@return ApiGetTaggedProjectsRequest
	*/
	GetTaggedProjects(ctx context.Context, name string) ApiGetTaggedProjectsRequest

	// GetTaggedProjectsExecute executes the request
	//  @return []TaggedProjectListResponseItem
	GetTaggedProjectsExecute(r ApiGetTaggedProjectsRequest) ([]TaggedProjectListResponseItem, *http.Response, error)

	/*
	GetTags Returns a list of all tags associated with a given policy

	<p><strong>Deprecated</strong>. Use <code>/api/v1/tag/policy/{uuid}</code> instead.</p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>


	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param policyUuid The UUID of the policy
	@return ApiGetTagsRequest

	Deprecated
	*/
	GetTags(ctx context.Context, policyUuid string) ApiGetTagsRequest

	// GetTagsExecute executes the request
	//  @return []Tag
	// Deprecated
	GetTagsExecute(r ApiGetTagsRequest) ([]Tag, *http.Response, error)

	/*
	GetTagsForPolicy Returns a list of all tags associated with a given policy

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the policy
	@return ApiGetTagsForPolicyRequest
	*/
	GetTagsForPolicy(ctx context.Context, uuid string) ApiGetTagsForPolicyRequest

	// GetTagsForPolicyExecute executes the request
	//  @return []Tag
	GetTagsForPolicyExecute(r ApiGetTagsForPolicyRequest) ([]Tag, *http.Response, error)

	/*
	TagNotificationRules Tags one or more notification rules.

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to assign
	@return ApiTagNotificationRulesRequest
	*/
	TagNotificationRules(ctx context.Context, name string) ApiTagNotificationRulesRequest

	// TagNotificationRulesExecute executes the request
	TagNotificationRulesExecute(r ApiTagNotificationRulesRequest) (*http.Response, error)

	/*
	TagPolicies Tags one or more policies.

	<p>Requires permission <strong>POLICY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to assign
	@return ApiTagPoliciesRequest
	*/
	TagPolicies(ctx context.Context, name string) ApiTagPoliciesRequest

	// TagPoliciesExecute executes the request
	TagPoliciesExecute(r ApiTagPoliciesRequest) (*http.Response, error)

	/*
	TagProjects Tags one or more projects.

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag to assign
	@return ApiTagProjectsRequest
	*/
	TagProjects(ctx context.Context, name string) ApiTagProjectsRequest

	// TagProjectsExecute executes the request
	TagProjectsExecute(r ApiTagProjectsRequest) (*http.Response, error)

	/*
	UntagNotificationRules Untags one or more notification rules.

	<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag
	@return ApiUntagNotificationRulesRequest
	*/
	UntagNotificationRules(ctx context.Context, name string) ApiUntagNotificationRulesRequest

	// UntagNotificationRulesExecute executes the request
	UntagNotificationRulesExecute(r ApiUntagNotificationRulesRequest) (*http.Response, error)

	/*
	UntagPolicies Untags one or more policies.

	<p>Requires permission <strong>POLICY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag
	@return ApiUntagPoliciesRequest
	*/
	UntagPolicies(ctx context.Context, name string) ApiUntagPoliciesRequest

	// UntagPoliciesExecute executes the request
	UntagPoliciesExecute(r ApiUntagPoliciesRequest) (*http.Response, error)

	/*
	UntagProjects Untags one or more projects.

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the tag
	@return ApiUntagProjectsRequest
	*/
	UntagProjects(ctx context.Context, name string) ApiUntagProjectsRequest

	// UntagProjectsExecute executes the request
	UntagProjectsExecute(r ApiUntagProjectsRequest) (*http.Response, error)
}

// TagAPIService TagAPI service
type TagAPIService service

type ApiCreateTagsRequest struct {
	ctx context.Context
	ApiService TagAPI
	requestBody *[]string
}

// Names of the tags to create
func (r ApiCreateTagsRequest) RequestBody(requestBody []string) ApiCreateTagsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiCreateTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTagsExecute(r)
}

/*
CreateTags Creates one or more tags.

<p>Requires permission <strong>TAG_MANAGEMENT</strong></p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTagsRequest
*/
func (a *TagAPIService) CreateTags(ctx context.Context) ApiCreateTagsRequest {
	return ApiCreateTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TagAPIService) CreateTagsExecute(r ApiCreateTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.CreateTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTagsRequest struct {
	ctx context.Context
	ApiService TagAPI
	requestBody *[]string
}

// Names of the tags to delete
func (r ApiDeleteTagsRequest) RequestBody(requestBody []string) ApiDeleteTagsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDeleteTagsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTagsExecute(r)
}

/*
DeleteTags Deletes one or more tags.

<p>A tag can only be deleted if no projects or policies are assigned to it.</p>
<p>
  Principals with <strong>PORTFOLIO_MANAGEMENT</strong> permission, and access
  to <em>all</em> assigned projects (if portfolio ACL is enabled), can delete
  a tag with assigned projects.
</p>
<p>
  Principals with <strong>POLICY_MANAGEMENT</strong> permission can delete tags
  with assigned policies.
</p>
<p>Requires permission <strong>TAG_MANAGEMENT</strong></p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTagsRequest
*/
func (a *TagAPIService) DeleteTags(ctx context.Context) ApiDeleteTagsRequest {
	return ApiDeleteTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TagAPIService) DeleteTagsExecute(r ApiDeleteTagsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.DeleteTags")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TagOperationProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllTagsRequest struct {
	ctx context.Context
	ApiService TagAPI
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetAllTagsRequest) PageNumber(pageNumber string) ApiGetAllTagsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetAllTagsRequest) PageSize(pageSize string) ApiGetAllTagsRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetAllTagsRequest) Offset(offset string) ApiGetAllTagsRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetAllTagsRequest) Limit(limit string) ApiGetAllTagsRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetAllTagsRequest) SortName(sortName string) ApiGetAllTagsRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetAllTagsRequest) SortOrder(sortOrder string) ApiGetAllTagsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetAllTagsRequest) Execute() ([]TagListResponseItem, *http.Response, error) {
	return r.ApiService.GetAllTagsExecute(r)
}

/*
GetAllTags Returns a list of all tags

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllTagsRequest
*/
func (a *TagAPIService) GetAllTags(ctx context.Context) ApiGetAllTagsRequest {
	return ApiGetAllTagsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TagListResponseItem
func (a *TagAPIService) GetAllTagsExecute(r ApiGetAllTagsRequest) ([]TagListResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TagListResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetAllTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaggedCollectionProjectsRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTaggedCollectionProjectsRequest) PageNumber(pageNumber string) ApiGetTaggedCollectionProjectsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTaggedCollectionProjectsRequest) PageSize(pageSize string) ApiGetTaggedCollectionProjectsRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTaggedCollectionProjectsRequest) Offset(offset string) ApiGetTaggedCollectionProjectsRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTaggedCollectionProjectsRequest) Limit(limit string) ApiGetTaggedCollectionProjectsRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTaggedCollectionProjectsRequest) SortName(sortName string) ApiGetTaggedCollectionProjectsRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTaggedCollectionProjectsRequest) SortOrder(sortOrder string) ApiGetTaggedCollectionProjectsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTaggedCollectionProjectsRequest) Execute() ([]TaggedCollectionProjectListResponseItem, *http.Response, error) {
	return r.ApiService.GetTaggedCollectionProjectsExecute(r)
}

/*
GetTaggedCollectionProjects Returns a list of all collection projects that use the given tag for their collection logic.

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to get collection projects for
 @return ApiGetTaggedCollectionProjectsRequest
*/
func (a *TagAPIService) GetTaggedCollectionProjects(ctx context.Context, name string) ApiGetTaggedCollectionProjectsRequest {
	return ApiGetTaggedCollectionProjectsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []TaggedCollectionProjectListResponseItem
func (a *TagAPIService) GetTaggedCollectionProjectsExecute(r ApiGetTaggedCollectionProjectsRequest) ([]TaggedCollectionProjectListResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaggedCollectionProjectListResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTaggedCollectionProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/collectionProject"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaggedNotificationRulesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTaggedNotificationRulesRequest) PageNumber(pageNumber string) ApiGetTaggedNotificationRulesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTaggedNotificationRulesRequest) PageSize(pageSize string) ApiGetTaggedNotificationRulesRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTaggedNotificationRulesRequest) Offset(offset string) ApiGetTaggedNotificationRulesRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTaggedNotificationRulesRequest) Limit(limit string) ApiGetTaggedNotificationRulesRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTaggedNotificationRulesRequest) SortName(sortName string) ApiGetTaggedNotificationRulesRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTaggedNotificationRulesRequest) SortOrder(sortOrder string) ApiGetTaggedNotificationRulesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTaggedNotificationRulesRequest) Execute() ([]TaggedPolicyListResponseItem, *http.Response, error) {
	return r.ApiService.GetTaggedNotificationRulesExecute(r)
}

/*
GetTaggedNotificationRules Returns a list of all notification rules assigned to the given tag.

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to get notification rules for
 @return ApiGetTaggedNotificationRulesRequest
*/
func (a *TagAPIService) GetTaggedNotificationRules(ctx context.Context, name string) ApiGetTaggedNotificationRulesRequest {
	return ApiGetTaggedNotificationRulesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []TaggedPolicyListResponseItem
func (a *TagAPIService) GetTaggedNotificationRulesExecute(r ApiGetTaggedNotificationRulesRequest) ([]TaggedPolicyListResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaggedPolicyListResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTaggedNotificationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/notificationRule"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaggedPoliciesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTaggedPoliciesRequest) PageNumber(pageNumber string) ApiGetTaggedPoliciesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTaggedPoliciesRequest) PageSize(pageSize string) ApiGetTaggedPoliciesRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTaggedPoliciesRequest) Offset(offset string) ApiGetTaggedPoliciesRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTaggedPoliciesRequest) Limit(limit string) ApiGetTaggedPoliciesRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTaggedPoliciesRequest) SortName(sortName string) ApiGetTaggedPoliciesRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTaggedPoliciesRequest) SortOrder(sortOrder string) ApiGetTaggedPoliciesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTaggedPoliciesRequest) Execute() ([]TaggedPolicyListResponseItem, *http.Response, error) {
	return r.ApiService.GetTaggedPoliciesExecute(r)
}

/*
GetTaggedPolicies Returns a list of all policies assigned to the given tag.

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to get policies for
 @return ApiGetTaggedPoliciesRequest
*/
func (a *TagAPIService) GetTaggedPolicies(ctx context.Context, name string) ApiGetTaggedPoliciesRequest {
	return ApiGetTaggedPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []TaggedPolicyListResponseItem
func (a *TagAPIService) GetTaggedPoliciesExecute(r ApiGetTaggedPoliciesRequest) ([]TaggedPolicyListResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaggedPolicyListResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTaggedPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTaggedProjectsRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTaggedProjectsRequest) PageNumber(pageNumber string) ApiGetTaggedProjectsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTaggedProjectsRequest) PageSize(pageSize string) ApiGetTaggedProjectsRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTaggedProjectsRequest) Offset(offset string) ApiGetTaggedProjectsRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTaggedProjectsRequest) Limit(limit string) ApiGetTaggedProjectsRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTaggedProjectsRequest) SortName(sortName string) ApiGetTaggedProjectsRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTaggedProjectsRequest) SortOrder(sortOrder string) ApiGetTaggedProjectsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTaggedProjectsRequest) Execute() ([]TaggedProjectListResponseItem, *http.Response, error) {
	return r.ApiService.GetTaggedProjectsExecute(r)
}

/*
GetTaggedProjects Returns a list of all projects assigned to the given tag.

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to get projects for
 @return ApiGetTaggedProjectsRequest
*/
func (a *TagAPIService) GetTaggedProjects(ctx context.Context, name string) ApiGetTaggedProjectsRequest {
	return ApiGetTaggedProjectsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
//  @return []TaggedProjectListResponseItem
func (a *TagAPIService) GetTaggedProjectsExecute(r ApiGetTaggedProjectsRequest) ([]TaggedProjectListResponseItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TaggedProjectListResponseItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTaggedProjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsRequest struct {
	ctx context.Context
	ApiService TagAPI
	policyUuid string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTagsRequest) PageNumber(pageNumber string) ApiGetTagsRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTagsRequest) PageSize(pageSize string) ApiGetTagsRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTagsRequest) Offset(offset string) ApiGetTagsRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTagsRequest) Limit(limit string) ApiGetTagsRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTagsRequest) SortName(sortName string) ApiGetTagsRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTagsRequest) SortOrder(sortOrder string) ApiGetTagsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTagsRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.GetTagsExecute(r)
}

/*
GetTags Returns a list of all tags associated with a given policy

<p><strong>Deprecated</strong>. Use <code>/api/v1/tag/policy/{uuid}</code> instead.</p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param policyUuid The UUID of the policy
 @return ApiGetTagsRequest

Deprecated
*/
func (a *TagAPIService) GetTags(ctx context.Context, policyUuid string) ApiGetTagsRequest {
	return ApiGetTagsRequest{
		ApiService: a,
		ctx: ctx,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return []Tag
// Deprecated
func (a *TagAPIService) GetTagsExecute(r ApiGetTagsRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTags")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTagsForPolicyRequest struct {
	ctx context.Context
	ApiService TagAPI
	uuid string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetTagsForPolicyRequest) PageNumber(pageNumber string) ApiGetTagsForPolicyRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetTagsForPolicyRequest) PageSize(pageSize string) ApiGetTagsForPolicyRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetTagsForPolicyRequest) Offset(offset string) ApiGetTagsForPolicyRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetTagsForPolicyRequest) Limit(limit string) ApiGetTagsForPolicyRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetTagsForPolicyRequest) SortName(sortName string) ApiGetTagsForPolicyRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetTagsForPolicyRequest) SortOrder(sortOrder string) ApiGetTagsForPolicyRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetTagsForPolicyRequest) Execute() ([]Tag, *http.Response, error) {
	return r.ApiService.GetTagsForPolicyExecute(r)
}

/*
GetTagsForPolicy Returns a list of all tags associated with a given policy

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the policy
 @return ApiGetTagsForPolicyRequest
*/
func (a *TagAPIService) GetTagsForPolicy(ctx context.Context, uuid string) ApiGetTagsForPolicyRequest {
	return ApiGetTagsForPolicyRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []Tag
func (a *TagAPIService) GetTagsForPolicyExecute(r ApiGetTagsForPolicyRequest) ([]Tag, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tag
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.GetTagsForPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/policy/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTagNotificationRulesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of notification rules to tag
func (r ApiTagNotificationRulesRequest) RequestBody(requestBody []string) ApiTagNotificationRulesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTagNotificationRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagNotificationRulesExecute(r)
}

/*
TagNotificationRules Tags one or more notification rules.

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to assign
 @return ApiTagNotificationRulesRequest
*/
func (a *TagAPIService) TagNotificationRules(ctx context.Context, name string) ApiTagNotificationRulesRequest {
	return ApiTagNotificationRulesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) TagNotificationRulesExecute(r ApiTagNotificationRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.TagNotificationRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/notificationRule"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTagPoliciesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of policies to tag
func (r ApiTagPoliciesRequest) RequestBody(requestBody []string) ApiTagPoliciesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTagPoliciesRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagPoliciesExecute(r)
}

/*
TagPolicies Tags one or more policies.

<p>Requires permission <strong>POLICY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to assign
 @return ApiTagPoliciesRequest
*/
func (a *TagAPIService) TagPolicies(ctx context.Context, name string) ApiTagPoliciesRequest {
	return ApiTagPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) TagPoliciesExecute(r ApiTagPoliciesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.TagPolicies")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTagProjectsRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of projects to tag
func (r ApiTagProjectsRequest) RequestBody(requestBody []string) ApiTagProjectsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTagProjectsRequest) Execute() (*http.Response, error) {
	return r.ApiService.TagProjectsExecute(r)
}

/*
TagProjects Tags one or more projects.

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag to assign
 @return ApiTagProjectsRequest
*/
func (a *TagAPIService) TagProjects(ctx context.Context, name string) ApiTagProjectsRequest {
	return ApiTagProjectsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) TagProjectsExecute(r ApiTagProjectsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.TagProjects")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUntagNotificationRulesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of notification rules to untag
func (r ApiUntagNotificationRulesRequest) RequestBody(requestBody []string) ApiUntagNotificationRulesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUntagNotificationRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UntagNotificationRulesExecute(r)
}

/*
UntagNotificationRules Untags one or more notification rules.

<p>Requires permission <strong>SYSTEM_CONFIGURATION</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag
 @return ApiUntagNotificationRulesRequest
*/
func (a *TagAPIService) UntagNotificationRules(ctx context.Context, name string) ApiUntagNotificationRulesRequest {
	return ApiUntagNotificationRulesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) UntagNotificationRulesExecute(r ApiUntagNotificationRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.UntagNotificationRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/notificationRule"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUntagPoliciesRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of policies to untag
func (r ApiUntagPoliciesRequest) RequestBody(requestBody []string) ApiUntagPoliciesRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUntagPoliciesRequest) Execute() (*http.Response, error) {
	return r.ApiService.UntagPoliciesExecute(r)
}

/*
UntagPolicies Untags one or more policies.

<p>Requires permission <strong>POLICY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag
 @return ApiUntagPoliciesRequest
*/
func (a *TagAPIService) UntagPolicies(ctx context.Context, name string) ApiUntagPoliciesRequest {
	return ApiUntagPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) UntagPoliciesExecute(r ApiUntagPoliciesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.UntagPolicies")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/policy"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUntagProjectsRequest struct {
	ctx context.Context
	ApiService TagAPI
	name string
	requestBody *[]string
}

// UUIDs of projects to untag
func (r ApiUntagProjectsRequest) RequestBody(requestBody []string) ApiUntagProjectsRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiUntagProjectsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UntagProjectsExecute(r)
}

/*
UntagProjects Untags one or more projects.

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Name of the tag
 @return ApiUntagProjectsRequest
*/
func (a *TagAPIService) UntagProjects(ctx context.Context, name string) ApiUntagProjectsRequest {
	return ApiUntagProjectsRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
	}
}

// Execute executes the request
func (a *TagAPIService) UntagProjectsExecute(r ApiUntagProjectsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TagAPIService.UntagProjects")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/tag/{name}/project"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return nil, reportError("requestBody is required and must be specified")
	}
	if len(*r.requestBody) < 1 {
		return nil, reportError("requestBody must have at least 1 elements")
	}
	if len(*r.requestBody) > 100 {
		return nil, reportError("requestBody must have less than 100 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
