/*
OWASP Dependency-Track

REST API of OWASP Dependency-Track

API version: 4.13.6
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type MetricsAPI interface {

	/*
	GetComponentCurrentMetrics Returns current metrics for a specific component

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the component to retrieve metrics for
	@return ApiGetComponentCurrentMetricsRequest
	*/
	GetComponentCurrentMetrics(ctx context.Context, uuid string) ApiGetComponentCurrentMetricsRequest

	// GetComponentCurrentMetricsExecute executes the request
	//  @return DependencyMetrics
	GetComponentCurrentMetricsExecute(r ApiGetComponentCurrentMetricsRequest) (*DependencyMetrics, *http.Response, error)

	/*
	GetComponentMetricsSince Returns historical metrics for a specific component from a specific date

	<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the component to retrieve metrics for
	@param date The start date to retrieve metrics for
	@return ApiGetComponentMetricsSinceRequest
	*/
	GetComponentMetricsSince(ctx context.Context, uuid string, date string) ApiGetComponentMetricsSinceRequest

	// GetComponentMetricsSinceExecute executes the request
	//  @return []DependencyMetrics
	GetComponentMetricsSinceExecute(r ApiGetComponentMetricsSinceRequest) ([]DependencyMetrics, *http.Response, error)

	/*
	GetComponentMetricsXDays Returns X days of historical metrics for a specific component

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the component to retrieve metrics for
	@param days The number of days back to retrieve metrics for
	@return ApiGetComponentMetricsXDaysRequest
	*/
	GetComponentMetricsXDays(ctx context.Context, uuid string, days int32) ApiGetComponentMetricsXDaysRequest

	// GetComponentMetricsXDaysExecute executes the request
	//  @return []DependencyMetrics
	GetComponentMetricsXDaysExecute(r ApiGetComponentMetricsXDaysRequest) ([]DependencyMetrics, *http.Response, error)

	/*
	GetPortfolioCurrentMetrics Returns current metrics for the entire portfolio

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPortfolioCurrentMetricsRequest
	*/
	GetPortfolioCurrentMetrics(ctx context.Context) ApiGetPortfolioCurrentMetricsRequest

	// GetPortfolioCurrentMetricsExecute executes the request
	//  @return PortfolioMetrics
	GetPortfolioCurrentMetricsExecute(r ApiGetPortfolioCurrentMetricsRequest) (*PortfolioMetrics, *http.Response, error)

	/*
	GetPortfolioMetricsSince Returns historical metrics for the entire portfolio from a specific date

	<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param date The start date to retrieve metrics for
	@return ApiGetPortfolioMetricsSinceRequest
	*/
	GetPortfolioMetricsSince(ctx context.Context, date string) ApiGetPortfolioMetricsSinceRequest

	// GetPortfolioMetricsSinceExecute executes the request
	//  @return []PortfolioMetrics
	GetPortfolioMetricsSinceExecute(r ApiGetPortfolioMetricsSinceRequest) ([]PortfolioMetrics, *http.Response, error)

	/*
	GetPortfolioMetricsXDays Returns X days of historical metrics for the entire portfolio

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param days The number of days back to retrieve metrics for
	@return ApiGetPortfolioMetricsXDaysRequest
	*/
	GetPortfolioMetricsXDays(ctx context.Context, days int32) ApiGetPortfolioMetricsXDaysRequest

	// GetPortfolioMetricsXDaysExecute executes the request
	//  @return []PortfolioMetrics
	GetPortfolioMetricsXDaysExecute(r ApiGetPortfolioMetricsXDaysRequest) ([]PortfolioMetrics, *http.Response, error)

	/*
	GetProjectCurrentMetrics Returns current metrics for a specific project

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the project to retrieve metrics for
	@return ApiGetProjectCurrentMetricsRequest
	*/
	GetProjectCurrentMetrics(ctx context.Context, uuid string) ApiGetProjectCurrentMetricsRequest

	// GetProjectCurrentMetricsExecute executes the request
	//  @return ProjectMetrics
	GetProjectCurrentMetricsExecute(r ApiGetProjectCurrentMetricsRequest) (*ProjectMetrics, *http.Response, error)

	/*
	GetProjectMetricsSince Returns historical metrics for a specific project from a specific date

	<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the project to retrieve metrics for
	@param date The start date to retrieve metrics for
	@return ApiGetProjectMetricsSinceRequest
	*/
	GetProjectMetricsSince(ctx context.Context, uuid string, date string) ApiGetProjectMetricsSinceRequest

	// GetProjectMetricsSinceExecute executes the request
	//  @return []ProjectMetrics
	GetProjectMetricsSinceExecute(r ApiGetProjectMetricsSinceRequest) ([]ProjectMetrics, *http.Response, error)

	/*
	GetProjectMetricsXDays Returns X days of historical metrics for a specific project

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the project to retrieve metrics for
	@param days The number of days back to retrieve metrics for
	@return ApiGetProjectMetricsXDaysRequest
	*/
	GetProjectMetricsXDays(ctx context.Context, uuid string, days int32) ApiGetProjectMetricsXDaysRequest

	// GetProjectMetricsXDaysExecute executes the request
	//  @return []ProjectMetrics
	GetProjectMetricsXDaysExecute(r ApiGetProjectMetricsXDaysRequest) ([]ProjectMetrics, *http.Response, error)

	/*
	GetVulnerabilityMetrics Returns the sum of all vulnerabilities in the database by year and month

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetVulnerabilityMetricsRequest
	*/
	GetVulnerabilityMetrics(ctx context.Context) ApiGetVulnerabilityMetricsRequest

	// GetVulnerabilityMetricsExecute executes the request
	//  @return []VulnerabilityMetrics
	GetVulnerabilityMetricsExecute(r ApiGetVulnerabilityMetricsRequest) ([]VulnerabilityMetrics, *http.Response, error)

	/*
	RefreshComponentMetrics Requests a refresh of a specific components metrics

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the component to refresh metrics on
	@return ApiRefreshComponentMetricsRequest
	*/
	RefreshComponentMetrics(ctx context.Context, uuid string) ApiRefreshComponentMetricsRequest

	// RefreshComponentMetricsExecute executes the request
	RefreshComponentMetricsExecute(r ApiRefreshComponentMetricsRequest) (*http.Response, error)

	/*
	RefreshPortfolioMetrics Requests a refresh of the portfolio metrics

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRefreshPortfolioMetricsRequest
	*/
	RefreshPortfolioMetrics(ctx context.Context) ApiRefreshPortfolioMetricsRequest

	// RefreshPortfolioMetricsExecute executes the request
	RefreshPortfolioMetricsExecute(r ApiRefreshPortfolioMetricsRequest) (*http.Response, error)

	/*
	RefreshProjectMetrics Requests a refresh of a specific projects metrics

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the project to refresh metrics on
	@return ApiRefreshProjectMetricsRequest
	*/
	RefreshProjectMetrics(ctx context.Context, uuid string) ApiRefreshProjectMetricsRequest

	// RefreshProjectMetricsExecute executes the request
	RefreshProjectMetricsExecute(r ApiRefreshProjectMetricsRequest) (*http.Response, error)
}

// MetricsAPIService MetricsAPI service
type MetricsAPIService service

type ApiGetComponentCurrentMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
}

func (r ApiGetComponentCurrentMetricsRequest) Execute() (*DependencyMetrics, *http.Response, error) {
	return r.ApiService.GetComponentCurrentMetricsExecute(r)
}

/*
GetComponentCurrentMetrics Returns current metrics for a specific component

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the component to retrieve metrics for
 @return ApiGetComponentCurrentMetricsRequest
*/
func (a *MetricsAPIService) GetComponentCurrentMetrics(ctx context.Context, uuid string) ApiGetComponentCurrentMetricsRequest {
	return ApiGetComponentCurrentMetricsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return DependencyMetrics
func (a *MetricsAPIService) GetComponentCurrentMetricsExecute(r ApiGetComponentCurrentMetricsRequest) (*DependencyMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependencyMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetComponentCurrentMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/component/{uuid}/current"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentMetricsSinceRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
	date string
}

func (r ApiGetComponentMetricsSinceRequest) Execute() ([]DependencyMetrics, *http.Response, error) {
	return r.ApiService.GetComponentMetricsSinceExecute(r)
}

/*
GetComponentMetricsSince Returns historical metrics for a specific component from a specific date

<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the component to retrieve metrics for
 @param date The start date to retrieve metrics for
 @return ApiGetComponentMetricsSinceRequest
*/
func (a *MetricsAPIService) GetComponentMetricsSince(ctx context.Context, uuid string, date string) ApiGetComponentMetricsSinceRequest {
	return ApiGetComponentMetricsSinceRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		date: date,
	}
}

// Execute executes the request
//  @return []DependencyMetrics
func (a *MetricsAPIService) GetComponentMetricsSinceExecute(r ApiGetComponentMetricsSinceRequest) ([]DependencyMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DependencyMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetComponentMetricsSince")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/component/{uuid}/since/{date}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetComponentMetricsXDaysRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
	days int32
}

func (r ApiGetComponentMetricsXDaysRequest) Execute() ([]DependencyMetrics, *http.Response, error) {
	return r.ApiService.GetComponentMetricsXDaysExecute(r)
}

/*
GetComponentMetricsXDays Returns X days of historical metrics for a specific component

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the component to retrieve metrics for
 @param days The number of days back to retrieve metrics for
 @return ApiGetComponentMetricsXDaysRequest
*/
func (a *MetricsAPIService) GetComponentMetricsXDays(ctx context.Context, uuid string, days int32) ApiGetComponentMetricsXDaysRequest {
	return ApiGetComponentMetricsXDaysRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		days: days,
	}
}

// Execute executes the request
//  @return []DependencyMetrics
func (a *MetricsAPIService) GetComponentMetricsXDaysExecute(r ApiGetComponentMetricsXDaysRequest) ([]DependencyMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DependencyMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetComponentMetricsXDays")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/component/{uuid}/days/{days}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"days"+"}", url.PathEscape(parameterValueToString(r.days, "days")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortfolioCurrentMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
}

func (r ApiGetPortfolioCurrentMetricsRequest) Execute() (*PortfolioMetrics, *http.Response, error) {
	return r.ApiService.GetPortfolioCurrentMetricsExecute(r)
}

/*
GetPortfolioCurrentMetrics Returns current metrics for the entire portfolio

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPortfolioCurrentMetricsRequest
*/
func (a *MetricsAPIService) GetPortfolioCurrentMetrics(ctx context.Context) ApiGetPortfolioCurrentMetricsRequest {
	return ApiGetPortfolioCurrentMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PortfolioMetrics
func (a *MetricsAPIService) GetPortfolioCurrentMetricsExecute(r ApiGetPortfolioCurrentMetricsRequest) (*PortfolioMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PortfolioMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetPortfolioCurrentMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/portfolio/current"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortfolioMetricsSinceRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	date string
}

func (r ApiGetPortfolioMetricsSinceRequest) Execute() ([]PortfolioMetrics, *http.Response, error) {
	return r.ApiService.GetPortfolioMetricsSinceExecute(r)
}

/*
GetPortfolioMetricsSince Returns historical metrics for the entire portfolio from a specific date

<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param date The start date to retrieve metrics for
 @return ApiGetPortfolioMetricsSinceRequest
*/
func (a *MetricsAPIService) GetPortfolioMetricsSince(ctx context.Context, date string) ApiGetPortfolioMetricsSinceRequest {
	return ApiGetPortfolioMetricsSinceRequest{
		ApiService: a,
		ctx: ctx,
		date: date,
	}
}

// Execute executes the request
//  @return []PortfolioMetrics
func (a *MetricsAPIService) GetPortfolioMetricsSinceExecute(r ApiGetPortfolioMetricsSinceRequest) ([]PortfolioMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PortfolioMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetPortfolioMetricsSince")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/portfolio/since/{date}"
	localVarPath = strings.Replace(localVarPath, "{"+"date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPortfolioMetricsXDaysRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	days int32
}

func (r ApiGetPortfolioMetricsXDaysRequest) Execute() ([]PortfolioMetrics, *http.Response, error) {
	return r.ApiService.GetPortfolioMetricsXDaysExecute(r)
}

/*
GetPortfolioMetricsXDays Returns X days of historical metrics for the entire portfolio

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param days The number of days back to retrieve metrics for
 @return ApiGetPortfolioMetricsXDaysRequest
*/
func (a *MetricsAPIService) GetPortfolioMetricsXDays(ctx context.Context, days int32) ApiGetPortfolioMetricsXDaysRequest {
	return ApiGetPortfolioMetricsXDaysRequest{
		ApiService: a,
		ctx: ctx,
		days: days,
	}
}

// Execute executes the request
//  @return []PortfolioMetrics
func (a *MetricsAPIService) GetPortfolioMetricsXDaysExecute(r ApiGetPortfolioMetricsXDaysRequest) ([]PortfolioMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PortfolioMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetPortfolioMetricsXDays")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/portfolio/{days}/days"
	localVarPath = strings.Replace(localVarPath, "{"+"days"+"}", url.PathEscape(parameterValueToString(r.days, "days")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectCurrentMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
}

func (r ApiGetProjectCurrentMetricsRequest) Execute() (*ProjectMetrics, *http.Response, error) {
	return r.ApiService.GetProjectCurrentMetricsExecute(r)
}

/*
GetProjectCurrentMetrics Returns current metrics for a specific project

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the project to retrieve metrics for
 @return ApiGetProjectCurrentMetricsRequest
*/
func (a *MetricsAPIService) GetProjectCurrentMetrics(ctx context.Context, uuid string) ApiGetProjectCurrentMetricsRequest {
	return ApiGetProjectCurrentMetricsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return ProjectMetrics
func (a *MetricsAPIService) GetProjectCurrentMetricsExecute(r ApiGetProjectCurrentMetricsRequest) (*ProjectMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProjectMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetProjectCurrentMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/project/{uuid}/current"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectMetricsSinceRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
	date string
}

func (r ApiGetProjectMetricsSinceRequest) Execute() ([]ProjectMetrics, *http.Response, error) {
	return r.ApiService.GetProjectMetricsSinceExecute(r)
}

/*
GetProjectMetricsSince Returns historical metrics for a specific project from a specific date

<p>Date format must be <code>YYYYMMDD</code></p>
<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the project to retrieve metrics for
 @param date The start date to retrieve metrics for
 @return ApiGetProjectMetricsSinceRequest
*/
func (a *MetricsAPIService) GetProjectMetricsSince(ctx context.Context, uuid string, date string) ApiGetProjectMetricsSinceRequest {
	return ApiGetProjectMetricsSinceRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		date: date,
	}
}

// Execute executes the request
//  @return []ProjectMetrics
func (a *MetricsAPIService) GetProjectMetricsSinceExecute(r ApiGetProjectMetricsSinceRequest) ([]ProjectMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProjectMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetProjectMetricsSince")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/project/{uuid}/since/{date}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"date"+"}", url.PathEscape(parameterValueToString(r.date, "date")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProjectMetricsXDaysRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
	days int32
}

func (r ApiGetProjectMetricsXDaysRequest) Execute() ([]ProjectMetrics, *http.Response, error) {
	return r.ApiService.GetProjectMetricsXDaysExecute(r)
}

/*
GetProjectMetricsXDays Returns X days of historical metrics for a specific project

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the project to retrieve metrics for
 @param days The number of days back to retrieve metrics for
 @return ApiGetProjectMetricsXDaysRequest
*/
func (a *MetricsAPIService) GetProjectMetricsXDays(ctx context.Context, uuid string, days int32) ApiGetProjectMetricsXDaysRequest {
	return ApiGetProjectMetricsXDaysRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		days: days,
	}
}

// Execute executes the request
//  @return []ProjectMetrics
func (a *MetricsAPIService) GetProjectMetricsXDaysExecute(r ApiGetProjectMetricsXDaysRequest) ([]ProjectMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ProjectMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetProjectMetricsXDays")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/project/{uuid}/days/{days}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"days"+"}", url.PathEscape(parameterValueToString(r.days, "days")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerabilityMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
}

func (r ApiGetVulnerabilityMetricsRequest) Execute() ([]VulnerabilityMetrics, *http.Response, error) {
	return r.ApiService.GetVulnerabilityMetricsExecute(r)
}

/*
GetVulnerabilityMetrics Returns the sum of all vulnerabilities in the database by year and month

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetVulnerabilityMetricsRequest
*/
func (a *MetricsAPIService) GetVulnerabilityMetrics(ctx context.Context) ApiGetVulnerabilityMetricsRequest {
	return ApiGetVulnerabilityMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []VulnerabilityMetrics
func (a *MetricsAPIService) GetVulnerabilityMetricsExecute(r ApiGetVulnerabilityMetricsRequest) ([]VulnerabilityMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []VulnerabilityMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.GetVulnerabilityMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/vulnerability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefreshComponentMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
}

func (r ApiRefreshComponentMetricsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshComponentMetricsExecute(r)
}

/*
RefreshComponentMetrics Requests a refresh of a specific components metrics

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the component to refresh metrics on
 @return ApiRefreshComponentMetricsRequest
*/
func (a *MetricsAPIService) RefreshComponentMetrics(ctx context.Context, uuid string) ApiRefreshComponentMetricsRequest {
	return ApiRefreshComponentMetricsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *MetricsAPIService) RefreshComponentMetricsExecute(r ApiRefreshComponentMetricsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.RefreshComponentMetrics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/component/{uuid}/refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRefreshPortfolioMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
}

func (r ApiRefreshPortfolioMetricsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshPortfolioMetricsExecute(r)
}

/*
RefreshPortfolioMetrics Requests a refresh of the portfolio metrics

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRefreshPortfolioMetricsRequest
*/
func (a *MetricsAPIService) RefreshPortfolioMetrics(ctx context.Context) ApiRefreshPortfolioMetricsRequest {
	return ApiRefreshPortfolioMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *MetricsAPIService) RefreshPortfolioMetricsExecute(r ApiRefreshPortfolioMetricsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.RefreshPortfolioMetrics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/portfolio/refresh"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRefreshProjectMetricsRequest struct {
	ctx context.Context
	ApiService MetricsAPI
	uuid string
}

func (r ApiRefreshProjectMetricsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RefreshProjectMetricsExecute(r)
}

/*
RefreshProjectMetrics Requests a refresh of a specific projects metrics

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the project to refresh metrics on
 @return ApiRefreshProjectMetricsRequest
*/
func (a *MetricsAPIService) RefreshProjectMetrics(ctx context.Context, uuid string) ApiRefreshProjectMetricsRequest {
	return ApiRefreshProjectMetricsRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *MetricsAPIService) RefreshProjectMetricsExecute(r ApiRefreshProjectMetricsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetricsAPIService.RefreshProjectMetrics")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/metrics/project/{uuid}/refresh"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
