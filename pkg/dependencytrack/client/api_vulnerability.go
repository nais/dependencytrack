/*
OWASP Dependency-Track

REST API of OWASP Dependency-Track

API version: 4.13.4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type VulnerabilityAPI interface {

	/*
	AssignVulnerability Assigns a vulnerability to a component

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the vulnerability
	@param component The UUID of the component
	@return ApiAssignVulnerabilityRequest
	*/
	AssignVulnerability(ctx context.Context, uuid string, component string) ApiAssignVulnerabilityRequest

	// AssignVulnerabilityExecute executes the request
	AssignVulnerabilityExecute(r ApiAssignVulnerabilityRequest) (*http.Response, error)

	/*
	AssignVulnerability1 Assigns a vulnerability to a component

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param source The vulnerability source
	@param vulnId The vulnId
	@param component The UUID of the component
	@return ApiAssignVulnerability1Request
	*/
	AssignVulnerability1(ctx context.Context, source string, vulnId string, component string) ApiAssignVulnerability1Request

	// AssignVulnerability1Execute executes the request
	AssignVulnerability1Execute(r ApiAssignVulnerability1Request) (*http.Response, error)

	/*
	CreateVulnerability Creates a new vulnerability

	<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateVulnerabilityRequest
	*/
	CreateVulnerability(ctx context.Context) ApiCreateVulnerabilityRequest

	// CreateVulnerabilityExecute executes the request
	//  @return Vulnerability
	CreateVulnerabilityExecute(r ApiCreateVulnerabilityRequest) (*Vulnerability, *http.Response, error)

	/*
	DeleteVulnerability Deletes a vulnerability

	<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the vulnerability to delete
	@return ApiDeleteVulnerabilityRequest
	*/
	DeleteVulnerability(ctx context.Context, uuid string) ApiDeleteVulnerabilityRequest

	// DeleteVulnerabilityExecute executes the request
	DeleteVulnerabilityExecute(r ApiDeleteVulnerabilityRequest) (*http.Response, error)

	/*
	GenerateInternalVulnerabilityIdentifier Generates an internal vulnerability identifier

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGenerateInternalVulnerabilityIdentifierRequest
	*/
	GenerateInternalVulnerabilityIdentifier(ctx context.Context) ApiGenerateInternalVulnerabilityIdentifierRequest

	// GenerateInternalVulnerabilityIdentifierExecute executes the request
	//  @return string
	GenerateInternalVulnerabilityIdentifierExecute(r ApiGenerateInternalVulnerabilityIdentifierRequest) (string, *http.Response, error)

	/*
	GetAffectedProject Returns a list of all projects affected by a specific vulnerability

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param source
	@param vuln
	@return ApiGetAffectedProjectRequest
	*/
	GetAffectedProject(ctx context.Context, source string, vuln string) ApiGetAffectedProjectRequest

	// GetAffectedProjectExecute executes the request
	//  @return []Project
	GetAffectedProjectExecute(r ApiGetAffectedProjectRequest) ([]Project, *http.Response, error)

	/*
	GetAllVulnerabilities Returns a list of all vulnerabilities

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllVulnerabilitiesRequest
	*/
	GetAllVulnerabilities(ctx context.Context) ApiGetAllVulnerabilitiesRequest

	// GetAllVulnerabilitiesExecute executes the request
	//  @return []Vulnerability
	GetAllVulnerabilitiesExecute(r ApiGetAllVulnerabilitiesRequest) ([]Vulnerability, *http.Response, error)

	/*
	GetVulnerabilitiesByComponent Returns a list of all vulnerabilities for a specific component

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the component to retrieve vulnerabilities for
	@return ApiGetVulnerabilitiesByComponentRequest
	*/
	GetVulnerabilitiesByComponent(ctx context.Context, uuid string) ApiGetVulnerabilitiesByComponentRequest

	// GetVulnerabilitiesByComponentExecute executes the request
	//  @return []Vulnerability
	GetVulnerabilitiesByComponentExecute(r ApiGetVulnerabilitiesByComponentRequest) ([]Vulnerability, *http.Response, error)

	/*
	GetVulnerabilitiesByProject Returns a list of all vulnerabilities for a specific project

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the project to retrieve vulnerabilities for
	@return ApiGetVulnerabilitiesByProjectRequest
	*/
	GetVulnerabilitiesByProject(ctx context.Context, uuid string) ApiGetVulnerabilitiesByProjectRequest

	// GetVulnerabilitiesByProjectExecute executes the request
	//  @return []Vulnerability
	GetVulnerabilitiesByProjectExecute(r ApiGetVulnerabilitiesByProjectRequest) ([]Vulnerability, *http.Response, error)

	/*
	GetVulnerabilityByUuid Returns a specific vulnerability

	<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the vulnerability
	@return ApiGetVulnerabilityByUuidRequest
	*/
	GetVulnerabilityByUuid(ctx context.Context, uuid string) ApiGetVulnerabilityByUuidRequest

	// GetVulnerabilityByUuidExecute executes the request
	//  @return Vulnerability
	GetVulnerabilityByUuidExecute(r ApiGetVulnerabilityByUuidRequest) (*Vulnerability, *http.Response, error)

	/*
	GetVulnerabilityByVulnId Returns a specific vulnerability

	<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param source
	@param vuln
	@return ApiGetVulnerabilityByVulnIdRequest
	*/
	GetVulnerabilityByVulnId(ctx context.Context, source string, vuln string) ApiGetVulnerabilityByVulnIdRequest

	// GetVulnerabilityByVulnIdExecute executes the request
	//  @return Vulnerability
	GetVulnerabilityByVulnIdExecute(r ApiGetVulnerabilityByVulnIdRequest) (*Vulnerability, *http.Response, error)

	/*
	UnassignVulnerability Removes assignment of a vulnerability from a component

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param uuid The UUID of the vulnerability
	@param component The UUID of the component
	@return ApiUnassignVulnerabilityRequest
	*/
	UnassignVulnerability(ctx context.Context, uuid string, component string) ApiUnassignVulnerabilityRequest

	// UnassignVulnerabilityExecute executes the request
	UnassignVulnerabilityExecute(r ApiUnassignVulnerabilityRequest) (*http.Response, error)

	/*
	UnassignVulnerability1 Removes assignment of a vulnerability from a component

	<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param source The vulnerability source
	@param vulnId The vulnId
	@param component The UUID of the component
	@return ApiUnassignVulnerability1Request
	*/
	UnassignVulnerability1(ctx context.Context, source string, vulnId string, component string) ApiUnassignVulnerability1Request

	// UnassignVulnerability1Execute executes the request
	UnassignVulnerability1Execute(r ApiUnassignVulnerability1Request) (*http.Response, error)

	/*
	UpdateVulnerability Updates an internal vulnerability

	<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateVulnerabilityRequest
	*/
	UpdateVulnerability(ctx context.Context) ApiUpdateVulnerabilityRequest

	// UpdateVulnerabilityExecute executes the request
	//  @return Vulnerability
	UpdateVulnerabilityExecute(r ApiUpdateVulnerabilityRequest) (*Vulnerability, *http.Response, error)
}

// VulnerabilityAPIService VulnerabilityAPI service
type VulnerabilityAPIService service

type ApiAssignVulnerabilityRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
	component string
}

func (r ApiAssignVulnerabilityRequest) Execute() (*http.Response, error) {
	return r.ApiService.AssignVulnerabilityExecute(r)
}

/*
AssignVulnerability Assigns a vulnerability to a component

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the vulnerability
 @param component The UUID of the component
 @return ApiAssignVulnerabilityRequest
*/
func (a *VulnerabilityAPIService) AssignVulnerability(ctx context.Context, uuid string, component string) ApiAssignVulnerabilityRequest {
	return ApiAssignVulnerabilityRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		component: component,
	}
}

// Execute executes the request
func (a *VulnerabilityAPIService) AssignVulnerabilityExecute(r ApiAssignVulnerabilityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.AssignVulnerability")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/{uuid}/component/{component}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiAssignVulnerability1Request struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	source string
	vulnId string
	component string
}

func (r ApiAssignVulnerability1Request) Execute() (*http.Response, error) {
	return r.ApiService.AssignVulnerability1Execute(r)
}

/*
AssignVulnerability1 Assigns a vulnerability to a component

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param source The vulnerability source
 @param vulnId The vulnId
 @param component The UUID of the component
 @return ApiAssignVulnerability1Request
*/
func (a *VulnerabilityAPIService) AssignVulnerability1(ctx context.Context, source string, vulnId string, component string) ApiAssignVulnerability1Request {
	return ApiAssignVulnerability1Request{
		ApiService: a,
		ctx: ctx,
		source: source,
		vulnId: vulnId,
		component: component,
	}
}

// Execute executes the request
func (a *VulnerabilityAPIService) AssignVulnerability1Execute(r ApiAssignVulnerability1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.AssignVulnerability1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/source/{source}/vuln/{vulnId}/component/{component}"
	localVarPath = strings.Replace(localVarPath, "{"+"source"+"}", url.PathEscape(parameterValueToString(r.source, "source")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vulnId"+"}", url.PathEscape(parameterValueToString(r.vulnId, "vulnId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateVulnerabilityRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	vulnerability *Vulnerability
}

func (r ApiCreateVulnerabilityRequest) Vulnerability(vulnerability Vulnerability) ApiCreateVulnerabilityRequest {
	r.vulnerability = &vulnerability
	return r
}

func (r ApiCreateVulnerabilityRequest) Execute() (*Vulnerability, *http.Response, error) {
	return r.ApiService.CreateVulnerabilityExecute(r)
}

/*
CreateVulnerability Creates a new vulnerability

<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateVulnerabilityRequest
*/
func (a *VulnerabilityAPIService) CreateVulnerability(ctx context.Context) ApiCreateVulnerabilityRequest {
	return ApiCreateVulnerabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Vulnerability
func (a *VulnerabilityAPIService) CreateVulnerabilityExecute(r ApiCreateVulnerabilityRequest) (*Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.CreateVulnerability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vulnerability
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVulnerabilityRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
}

func (r ApiDeleteVulnerabilityRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVulnerabilityExecute(r)
}

/*
DeleteVulnerability Deletes a vulnerability

<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the vulnerability to delete
 @return ApiDeleteVulnerabilityRequest
*/
func (a *VulnerabilityAPIService) DeleteVulnerability(ctx context.Context, uuid string) ApiDeleteVulnerabilityRequest {
	return ApiDeleteVulnerabilityRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
func (a *VulnerabilityAPIService) DeleteVulnerabilityExecute(r ApiDeleteVulnerabilityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.DeleteVulnerability")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGenerateInternalVulnerabilityIdentifierRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
}

func (r ApiGenerateInternalVulnerabilityIdentifierRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GenerateInternalVulnerabilityIdentifierExecute(r)
}

/*
GenerateInternalVulnerabilityIdentifier Generates an internal vulnerability identifier

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGenerateInternalVulnerabilityIdentifierRequest
*/
func (a *VulnerabilityAPIService) GenerateInternalVulnerabilityIdentifier(ctx context.Context) ApiGenerateInternalVulnerabilityIdentifierRequest {
	return ApiGenerateInternalVulnerabilityIdentifierRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *VulnerabilityAPIService) GenerateInternalVulnerabilityIdentifierExecute(r ApiGenerateInternalVulnerabilityIdentifierRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GenerateInternalVulnerabilityIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/vulnId"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAffectedProjectRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	source string
	vuln string
	excludeInactive *bool
}

// Optionally excludes inactive projects from being returned
func (r ApiGetAffectedProjectRequest) ExcludeInactive(excludeInactive bool) ApiGetAffectedProjectRequest {
	r.excludeInactive = &excludeInactive
	return r
}

func (r ApiGetAffectedProjectRequest) Execute() ([]Project, *http.Response, error) {
	return r.ApiService.GetAffectedProjectExecute(r)
}

/*
GetAffectedProject Returns a list of all projects affected by a specific vulnerability

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param source
 @param vuln
 @return ApiGetAffectedProjectRequest
*/
func (a *VulnerabilityAPIService) GetAffectedProject(ctx context.Context, source string, vuln string) ApiGetAffectedProjectRequest {
	return ApiGetAffectedProjectRequest{
		ApiService: a,
		ctx: ctx,
		source: source,
		vuln: vuln,
	}
}

// Execute executes the request
//  @return []Project
func (a *VulnerabilityAPIService) GetAffectedProjectExecute(r ApiGetAffectedProjectRequest) ([]Project, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Project
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetAffectedProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/source/{source}/vuln/{vuln}/projects"
	localVarPath = strings.Replace(localVarPath, "{"+"source"+"}", url.PathEscape(parameterValueToString(r.source, "source")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vuln"+"}", url.PathEscape(parameterValueToString(r.vuln, "vuln")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.excludeInactive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInactive", r.excludeInactive, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllVulnerabilitiesRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetAllVulnerabilitiesRequest) PageNumber(pageNumber string) ApiGetAllVulnerabilitiesRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetAllVulnerabilitiesRequest) PageSize(pageSize string) ApiGetAllVulnerabilitiesRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetAllVulnerabilitiesRequest) Offset(offset string) ApiGetAllVulnerabilitiesRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetAllVulnerabilitiesRequest) Limit(limit string) ApiGetAllVulnerabilitiesRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetAllVulnerabilitiesRequest) SortName(sortName string) ApiGetAllVulnerabilitiesRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetAllVulnerabilitiesRequest) SortOrder(sortOrder string) ApiGetAllVulnerabilitiesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetAllVulnerabilitiesRequest) Execute() ([]Vulnerability, *http.Response, error) {
	return r.ApiService.GetAllVulnerabilitiesExecute(r)
}

/*
GetAllVulnerabilities Returns a list of all vulnerabilities

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllVulnerabilitiesRequest
*/
func (a *VulnerabilityAPIService) GetAllVulnerabilities(ctx context.Context) ApiGetAllVulnerabilitiesRequest {
	return ApiGetAllVulnerabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Vulnerability
func (a *VulnerabilityAPIService) GetAllVulnerabilitiesExecute(r ApiGetAllVulnerabilitiesRequest) ([]Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetAllVulnerabilities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerabilitiesByComponentRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
	pageNumber *string
	pageSize *string
	offset *string
	limit *string
	sortName *string
	sortOrder *string
	suppressed *bool
}

// The page to return. To be used in conjunction with &lt;code&gt;pageSize&lt;/code&gt;.
func (r ApiGetVulnerabilitiesByComponentRequest) PageNumber(pageNumber string) ApiGetVulnerabilitiesByComponentRequest {
	r.pageNumber = &pageNumber
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;pageNumber&lt;/code&gt;.
func (r ApiGetVulnerabilitiesByComponentRequest) PageSize(pageSize string) ApiGetVulnerabilitiesByComponentRequest {
	r.pageSize = &pageSize
	return r
}

// Offset to start returning elements from. To be used in conjunction with &lt;code&gt;limit&lt;/code&gt;.
func (r ApiGetVulnerabilitiesByComponentRequest) Offset(offset string) ApiGetVulnerabilitiesByComponentRequest {
	r.offset = &offset
	return r
}

// Number of elements to return per page. To be used in conjunction with &lt;code&gt;offset&lt;/code&gt;.
func (r ApiGetVulnerabilitiesByComponentRequest) Limit(limit string) ApiGetVulnerabilitiesByComponentRequest {
	r.limit = &limit
	return r
}

// Name of the resource field to sort on.
func (r ApiGetVulnerabilitiesByComponentRequest) SortName(sortName string) ApiGetVulnerabilitiesByComponentRequest {
	r.sortName = &sortName
	return r
}

// Ordering of items when sorting with &lt;code&gt;sortName&lt;/code&gt;.
func (r ApiGetVulnerabilitiesByComponentRequest) SortOrder(sortOrder string) ApiGetVulnerabilitiesByComponentRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optionally includes suppressed vulnerabilities
func (r ApiGetVulnerabilitiesByComponentRequest) Suppressed(suppressed bool) ApiGetVulnerabilitiesByComponentRequest {
	r.suppressed = &suppressed
	return r
}

func (r ApiGetVulnerabilitiesByComponentRequest) Execute() ([]Vulnerability, *http.Response, error) {
	return r.ApiService.GetVulnerabilitiesByComponentExecute(r)
}

/*
GetVulnerabilitiesByComponent Returns a list of all vulnerabilities for a specific component

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the component to retrieve vulnerabilities for
 @return ApiGetVulnerabilitiesByComponentRequest
*/
func (a *VulnerabilityAPIService) GetVulnerabilitiesByComponent(ctx context.Context, uuid string) ApiGetVulnerabilitiesByComponentRequest {
	return ApiGetVulnerabilitiesByComponentRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []Vulnerability
func (a *VulnerabilityAPIService) GetVulnerabilitiesByComponentExecute(r ApiGetVulnerabilitiesByComponentRequest) ([]Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetVulnerabilitiesByComponent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/component/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue string = "1"
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	} else {
		var defaultValue string = "100"
		r.pageSize = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortName", r.sortName, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.suppressed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressed", r.suppressed, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerabilitiesByProjectRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
	suppressed *bool
}

// Optionally includes suppressed vulnerabilities
func (r ApiGetVulnerabilitiesByProjectRequest) Suppressed(suppressed bool) ApiGetVulnerabilitiesByProjectRequest {
	r.suppressed = &suppressed
	return r
}

func (r ApiGetVulnerabilitiesByProjectRequest) Execute() ([]Vulnerability, *http.Response, error) {
	return r.ApiService.GetVulnerabilitiesByProjectExecute(r)
}

/*
GetVulnerabilitiesByProject Returns a list of all vulnerabilities for a specific project

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the project to retrieve vulnerabilities for
 @return ApiGetVulnerabilitiesByProjectRequest
*/
func (a *VulnerabilityAPIService) GetVulnerabilitiesByProject(ctx context.Context, uuid string) ApiGetVulnerabilitiesByProjectRequest {
	return ApiGetVulnerabilitiesByProjectRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return []Vulnerability
func (a *VulnerabilityAPIService) GetVulnerabilitiesByProjectExecute(r ApiGetVulnerabilitiesByProjectRequest) ([]Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetVulnerabilitiesByProject")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/project/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.suppressed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressed", r.suppressed, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerabilityByUuidRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
}

func (r ApiGetVulnerabilityByUuidRequest) Execute() (*Vulnerability, *http.Response, error) {
	return r.ApiService.GetVulnerabilityByUuidExecute(r)
}

/*
GetVulnerabilityByUuid Returns a specific vulnerability

<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the vulnerability
 @return ApiGetVulnerabilityByUuidRequest
*/
func (a *VulnerabilityAPIService) GetVulnerabilityByUuid(ctx context.Context, uuid string) ApiGetVulnerabilityByUuidRequest {
	return ApiGetVulnerabilityByUuidRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
	}
}

// Execute executes the request
//  @return Vulnerability
func (a *VulnerabilityAPIService) GetVulnerabilityByUuidExecute(r ApiGetVulnerabilityByUuidRequest) (*Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetVulnerabilityByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/{uuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerabilityByVulnIdRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	source string
	vuln string
}

func (r ApiGetVulnerabilityByVulnIdRequest) Execute() (*Vulnerability, *http.Response, error) {
	return r.ApiService.GetVulnerabilityByVulnIdExecute(r)
}

/*
GetVulnerabilityByVulnId Returns a specific vulnerability

<p>Requires permission <strong>VIEW_PORTFOLIO</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param source
 @param vuln
 @return ApiGetVulnerabilityByVulnIdRequest
*/
func (a *VulnerabilityAPIService) GetVulnerabilityByVulnId(ctx context.Context, source string, vuln string) ApiGetVulnerabilityByVulnIdRequest {
	return ApiGetVulnerabilityByVulnIdRequest{
		ApiService: a,
		ctx: ctx,
		source: source,
		vuln: vuln,
	}
}

// Execute executes the request
//  @return Vulnerability
func (a *VulnerabilityAPIService) GetVulnerabilityByVulnIdExecute(r ApiGetVulnerabilityByVulnIdRequest) (*Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.GetVulnerabilityByVulnId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/source/{source}/vuln/{vuln}"
	localVarPath = strings.Replace(localVarPath, "{"+"source"+"}", url.PathEscape(parameterValueToString(r.source, "source")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vuln"+"}", url.PathEscape(parameterValueToString(r.vuln, "vuln")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnassignVulnerabilityRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	uuid string
	component string
}

func (r ApiUnassignVulnerabilityRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnassignVulnerabilityExecute(r)
}

/*
UnassignVulnerability Removes assignment of a vulnerability from a component

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param uuid The UUID of the vulnerability
 @param component The UUID of the component
 @return ApiUnassignVulnerabilityRequest
*/
func (a *VulnerabilityAPIService) UnassignVulnerability(ctx context.Context, uuid string, component string) ApiUnassignVulnerabilityRequest {
	return ApiUnassignVulnerabilityRequest{
		ApiService: a,
		ctx: ctx,
		uuid: uuid,
		component: component,
	}
}

// Execute executes the request
func (a *VulnerabilityAPIService) UnassignVulnerabilityExecute(r ApiUnassignVulnerabilityRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.UnassignVulnerability")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/{uuid}/component/{component}"
	localVarPath = strings.Replace(localVarPath, "{"+"uuid"+"}", url.PathEscape(parameterValueToString(r.uuid, "uuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnassignVulnerability1Request struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	source string
	vulnId string
	component string
}

func (r ApiUnassignVulnerability1Request) Execute() (*http.Response, error) {
	return r.ApiService.UnassignVulnerability1Execute(r)
}

/*
UnassignVulnerability1 Removes assignment of a vulnerability from a component

<p>Requires permission <strong>PORTFOLIO_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param source The vulnerability source
 @param vulnId The vulnId
 @param component The UUID of the component
 @return ApiUnassignVulnerability1Request
*/
func (a *VulnerabilityAPIService) UnassignVulnerability1(ctx context.Context, source string, vulnId string, component string) ApiUnassignVulnerability1Request {
	return ApiUnassignVulnerability1Request{
		ApiService: a,
		ctx: ctx,
		source: source,
		vulnId: vulnId,
		component: component,
	}
}

// Execute executes the request
func (a *VulnerabilityAPIService) UnassignVulnerability1Execute(r ApiUnassignVulnerability1Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.UnassignVulnerability1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability/source/{source}/vuln/{vulnId}/component/{component}"
	localVarPath = strings.Replace(localVarPath, "{"+"source"+"}", url.PathEscape(parameterValueToString(r.source, "source")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"vulnId"+"}", url.PathEscape(parameterValueToString(r.vulnId, "vulnId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"component"+"}", url.PathEscape(parameterValueToString(r.component, "component")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVulnerabilityRequest struct {
	ctx context.Context
	ApiService VulnerabilityAPI
	vulnerability *Vulnerability
}

func (r ApiUpdateVulnerabilityRequest) Vulnerability(vulnerability Vulnerability) ApiUpdateVulnerabilityRequest {
	r.vulnerability = &vulnerability
	return r
}

func (r ApiUpdateVulnerabilityRequest) Execute() (*Vulnerability, *http.Response, error) {
	return r.ApiService.UpdateVulnerabilityExecute(r)
}

/*
UpdateVulnerability Updates an internal vulnerability

<p>Requires permission <strong>VULNERABILITY_MANAGEMENT</strong></p>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateVulnerabilityRequest
*/
func (a *VulnerabilityAPIService) UpdateVulnerability(ctx context.Context) ApiUpdateVulnerabilityRequest {
	return ApiUpdateVulnerabilityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Vulnerability
func (a *VulnerabilityAPIService) UpdateVulnerabilityExecute(r ApiUpdateVulnerabilityRequest) (*Vulnerability, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Vulnerability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VulnerabilityAPIService.UpdateVulnerability")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/vulnerability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vulnerability
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Api-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
